@startuml

together {
    interface Command {
        execute(system: Any): Unit
    }
    note bottom of Command
        // Transfer $20 between accounts
        bank[to].balance += 20
        bank[from].balance -= 20
    end note

    interface Query {
        execute(system: Any): Any?
    }
    note bottom of Query
        // Names for accounts with a $70 balance
        bank.accounts.values
            .filter { it.balance == 70 }
            .map { it.name }
            .toSet()
    end note
}

together {
    interface EventSourcing {
        <E> replay(eventConsumer: (E) -> Unit): Unit
        append(event: Any): Unit
    }
    note bottom of EventSourcing
        - Stores all commands (events)
           on persistent storage
        - In-memory state reconstructed
           by replaying stored commands
    end note
    interface TxMgr {
        + begin(): Unit
        + remember(who: Any, what: String, value: T, undo: (T) -> Unit): Unit
        + rollback(): Unit
    }
    note bottom of TxMgr
        A poor man's STM:
        Mutable properties participate
        in thread-local transactions
    end note
}

class MemoryImage {
    + execute(command: Command)
    + execute(query: Query)
}
MemoryImage ..> Command: runs >
MemoryImage ..> Query: runs >
MemoryImage --> EventSourcing: persists commands with >
MemoryImage --> TxMgr: ensures integrity through >

@enduml